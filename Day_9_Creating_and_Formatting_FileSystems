...........18.18-Day-9_Creating_and_Formatting_FileSystems.....................................

# file-systems in linux : is resbonsable for store an manage the data on the disks


- File system is a collection of files and directories stored on disk. Each file system is

- stored in a separate whole disk partition. The following are a few of the file system:

* ext4 
* xfs
* fat
* nfs
* tfs

File system divided into two categories:

* User data — Stores actual data contained in files.
* Metadata  — Stores file system structural information such as superblock, inodes, directories.

- Partition divided into blocks
* Super block
* Data block
* Inode blocks


-------------------------------------

What is Superblock?

Each file system is different, and they have type like ext2, ext3 etc.

Further each file system has size like 5 GB, IO GB and status such as
mount status. In short, each file system has a superblock, which contains
information about file system such as:
• File system type
• Status Size
• Information about other metadata structures
-----------------------------------------------

What is Inodes?

it is a metadata about the files like :

* File type (executable, block special etc)

* Permissions (read, write etc)
* Owner
* Group
* File size
* File access, change and modification time
* Number of links (soft/hard)
* Access Control List (ACLs)
------------------------------------------------------

Partitioning a Disk :

Disk partitioning allows system administrators to divide a hard drive into multiple
logical storage units, referred to as partitions. By separating a disk into partitions,
system administrators can use different partitions to perform different functions.

- For example, disk partitioning is necessary or beneficial in these situations:
* Limit available space to applications or users.
* Separate operating system and program files from user files.
* Create a separate area for memory swapping.
* Limit disk space use to improve the performance of diagnostic tools and backup imaging.
------------------------------------------------------------------------------------------------
# the partitioning Scheme : is the method or format to patition the disk into logical sections or partitons 

- we have two types of partitionnig scheme :
  1- MBR ( master boot recorde )
  2- GPT

- MBR :

* Since 1982, the Master Boot Record (MBR) partitioning scheme has dictated how disks are partitioned on systems.


* This scheme supports a maximum of four primary partitions.

* to use more partitions we make the last partion work as Extended partiton ,so we can create logical partions on it 

* On Linux systems, with the use of extended and logical partitions, administrators can create a maximum of 15 partitions. Because partition size data is stored as 32-bit values,

* disks partitioned with the MBR scheme have a maximum disk and partition size of 2 TiB.

------------------------
 
# the MPR is consist of :

1- boot strabe code : is the frist 446 byte , its job is to loade the bootloader witch boot the operating system when the system is booting up 

2- prtition- table  : it's 64 byte , containe the inodes of the prtitions created on our system and many informations like {size ,type ,status of the partition }

3- the magice number: witch is 2 byte and its an hexadicemal number used by the bios to see wether the MBR is corrapted or not


# the MPR have no redundancy : so if the MPR has corrapted then we can't have the data on the disk again.

---------------------------------------------------------------------------------------------------------------


# Primary partition  :

- These are the convention partitions that would create by default.

- If you only plan to create 4 partitions or less, then you only need to create primary partition and you don't have to worry about extended and logical partitions .

- if 4 primary partitions created then we can't creat extended partion.

# Extended partition : 

- If you want to create more than 4 partitions on a hdd, now or in the future,then you need to create one of the partition as an extended partition.

- An extended partition is not actually a partition, instead it is essentially an empty container inside which you can create (logical) partitions.

- You cannot store data inside an extended partition directly, instead you first have to create logical partition inside the extended partition. 

- You can only create one extended partition per hdd.  


# Logical partition 

— These are the names of any partitions created inside an extended partition,OS uses logical partitions in the same was as a typical primary partition.



Primary Area Only contain:                      
* Primary Area 1
* Primary Area 2
* Primary Area 3
* Primary Area 4

Extended Area Only :
* Primary Area 1
* Primary Area 2
* Primary Area 3
* Extended Partition
   - Logical Area 1
   - Logical Area 2
------------------------------


# GPT ( globally unique identifier )  Partitioning Scheme:

- the GPT has redundancy as we can has an backup copy of the gpt so if the orignal one has corrapted we can reuse the copy backup to restore the data

- A GPT provides a maximum of 128 partitions. Unlike an MBR, which uses 32 bits for storing logical block addresses and size information.

- a GPT allocates 64 bits for logical block addresses.

- Allows a GPT to accommodate partitions and disks of up to eight zebibytes (ZiB) or eight billion tebibytes.

- In addition to addressing the limitations of the MBR partitioning scheme, a GPT also offers some additional features and benefits.

- A GPT uses a globally unique identifier (GUID) to identify each disk and partition.

- In contrast to an MBR, which has a single point of failure, a GPT offers redundancy of its partition table information.

- The primary GPT resides at the head of the disk, while a backup copy, the secondary GPT, is housed at the end of the disk.

-  A GPT uses a checksum to detect errors and corruptions in the GPT header and partition table.

# Should I Use MBR or GPT in Linux?

- One of the biggest advantages of GPT over MBR is, on an MBR disk,
the partitioning and boot data is stored in one place.

- If this data is corrupted, you're in trouble meanwhile in GPT stores multiple copies
ofthis data across the disk, so you can recover
if the datais corrupted.


#####################################################################################
# Managing Partitions With Parted

- Partition editors are programs which allow administrators to make changes to a disk's partitions, such as creating partitions, deleting partitions, and changing partition types.

- To perform these operations, administrators can use :

[ the Parted partition editor for both the MBR and the GPT partitioning scheme ]


[ command : parted devic-path subcommands ]

- The parted command takes the device name of the whole disk as the first argument and one or more subcommands.

- The following example uses the print subcommand to display the partition table on the /dev/sda disk.


[root@server ~]# parted /dev/sda print

Model: VMware, VMware Virtual S (scsi)

Disk /dev/sda: 21.5GB

Sector size (logical/physical): 512B/512B

Partition Table: msdos

Disk Flags:

Number  Start   End     Size    Type     File system  Flags
 1      1049kB  1075MB  1074MB  primary  xfs          boot
 2      1075MB  21.5GB  20.4GB  primary               lvm



- we can opens an interactive session for for using commads on the disk we want to manage with command :

[ parted dev-path ]


[root@server ~]# parted /dev/sdb
GNU Parted 3.5
Using /dev/sdb

Welcome to GNU Parted! Type 'help' to view a list of commands.

(parted)

 ------------------------------------------------------------------

# By default, parted displays all the sizes in powers of 10 (KB, MB, GB).

# You can change that default with the unit subcommand which accepts the following parameters:

• s for sector

• B for byte

• MB, GB, or TB (powers of IO)


[root@server ~]# parted /dev/sda unit s print
Model: VMware, VMware Virtual S (scsi)
Disk /dev/sda: 41943040s
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Disk Flags:

Number  Start     End        Size       Type     File system  Flags
 1      2048s     2099199s   2097152s   primary  xfs          boot
 2      2099200s  41943039s  39843840s  primary               lvm


----------------------------------------------------------------

# Writing the Partition Table on a New Disk

- To partition a new drive, you first have to write a disk label to it. 

- The disk label indicates which partitioning scheme to use.

- Keep in mind that parted makes the changes immediately.

- A mistake with parted could definitely lead to data loss.

- As the root user, use the following command to write an MBR disk label to a disk:


[root@server ~]# parted /dev/sdb mklabel msdos

Warning: The existing disk label on /dev/sdb will be destroyed and all data on this disk will be lost. Do you want to continue? 
Yes/No? y
Information: You may need to update /etc/fstab.

# to wtite a gpt disk label :

[ command : parted disk-path mklabel gpt ]


[root@server ~]# parted /dev/sdb mklabel gpt

Warning: The existing disk label on /dev/sdb will be destroyed and all data

on this disk will be lost. Do you want to continue?

Yes/No? y

Information: You may need to update /etc/fstab.

   - The mklabel subcommand wipes the existing partition table.

   - Only use mklabel when the intent is to reuse the disk without regard to the existing data. 

   - If a new label changes the partition boundaries, all data in existing file systems will become inaccessible.
------------------

# to get help with subcommand usage in the parted prompot use ( help ) befor the subcommand 


[root@server ~]# parted /dev/sdb
GNU Parted 3.5
Using /dev/sdb
Welcome to GNU Parted! Type 'help' to view a list of commands.

(parted) help mk

mklabel  mkpart   mktable

(parted) help mklabel

  mklabel,mktable LABEL-TYPE               create a new disklabel
        (partition table)

        LABEL-TYPE is one of: aix, amiga, bsd, dvh, gpt, mac, msdos,
        pc98, sun, atari, loop

--------------
# to see the file system we can make on partition :

[ command : parted partition-path help mkpart ]


[root@server ~]# parted /dev/sdb help mkpart

  mkpart PART-TYPE [FS-TYPE] START END     make a partition

        PART-TYPE is one of: primary, logical, extended
        FS-TYPE is one of: udf, btrfs, nilfs2, ext4, ext3, ext2,
        f2fs, fat32, fat16, hfsx, hfs+, hfs, jfs, swsusp,
        linux-swap(v1), linux-swap(v0), ntfs, reiserfs, hp-ufs,
        sun-ufs, xfs, apfs2, apfs1, asfs, amufs5, amufs4, amufs3,
        amufs2, amufs1, amufs0, amufs, affs7, affs6, affs5, affs4,
        affs3, affs2, affs1, affs0, linux-swap, linux-swap(new),
        linux-swap(old)
        START and END are disk locations, such as 4GB or 10%.
        Negative values count from the end of the disk.  For
        example, -1s specifies exactly the last sector.

        'mkpart' makes a partition without creating a new file
        system on the partition.  FS-TYPE may be specified to set an
        appropriate partition ID.
----------
# Creating MBR Partitions

1 - Specify the disk device to create the partition on.

  - As the root user, execute the parted command and specify the disk device name as an argument.
  
  - This starts the parted command in interactive mode and displays a command prompt.



[root@server ~]# parted /dev/sdb

GNU Parted 3.5

Using /dev/sdb

Welcome to GNU Parted! Type 'help' to view a list of commands.

(parted)


2- Use the mkpart subcommand to create a new primary or extended partition.

(parted) mkpart

Partition type? primary/extended? primary


- For situations where you need more than four partitions on an MBR-partitioned disk, create three primary partitions and one extended partition.

- This extended partition serves as a container within which you can create multiple logical partitions.

3- Indicate the file-system type that you want to create on the partition, such as xfs or ext4.

     -This does not create the file system on the partition; it is only an indication of the partition type.


            File system type? [ext2]? xfs

         - To get the list of the supported file-system types, use the following command:
    
         [root@host] parted /dev/sdb help mkpart

4- Specify the sector on the disk that the new partition starts on.
         
       Start? 2048s

- Notice the s suffix to provide the value in sectors.
   
   You can also use the MB, GB, or TB suffixes.
   
   - If you do not provide a suffix, MB is the default.


5- Specify the disk sector where the new partition should end.

     End? IOOOMB

- As soon as you provide the end position, parted updates the partition table on the disk with the new partition details.


6- Exit parted.
  
  (parted) quit
Information: You may need to update /etc/fstab.


7- Run the udevadm settle command. 


- This command waits for the system to detect the new partition and to create the associated device file under the /dev directory.

- It only returns when it is done.

[ command : udevadm settle ]

like : partprobe command 

- As an alternative to the interactive mode, you can also create the partition as follows:

[root@host parted /dev/vdb mkpart primary xfs 2048s 1000MB

- As an alternative to the interactive mode, you can also create the
partition as follows:

parted /dev/nvmeOn2 <<END
mkpart primary 0% 10% <<<<<<<<<<<<< to idecate the 10 percentage of the total disk
quit
END

# Creating GPT partition :

- the same steps but it will not ask for the partition type (primary or extended ) as he deal with all partions as its primary partitons

#################################################################################################################

# to show the attatched diskes

[command :lsblk ]


[root@server ~]# lsblk
NAME        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
sda           8:0    0   20G  0 disk
├─sda1        8:1    0    1G  0 part /boot
└─sda2        8:2    0   19G  0 part
  ├─rhel-root
  │         253:0    0   17G  0 lvm  /var/lib/containers/storage/overlay
  │                                  /
  └─rhel-swap
            253:1    0    2G  0 lvm  [SWAP]
sdb           8:16   0    5G  0 disk
sr0          11:0    1 10.3G  0 rom  /run/media/mo/RHEL-9-4-0-BaseOS-x86_64

- NOTE : device sr0 : is the iso image  we installed the operating system from it .

.......................................................

- NOTE:

when creating hard disk the bios try to detect the new disk but it must restart the machine

...................................................................

NOTE : WE CAN rescane the attatched nwe hard ware to detect it by 
bacage sg3

-------------------------------------------------------

# to list all partitions with the file systems created on it 

[ command : lsblk -f ]


[root@server ~]# lsblk -f
NAME           FSTYPE FSVER LABEL UUID                                   FSAVAIL FSUSE% MOUNTPOINTS
sda

├─sda1
│                xfs                ce5b5924-8f6e-4706-877c-b0782773298f    548.1M    43% /boot
└─sda2
                 LVM2_m LVM2        RhI2Wm-eZjz-jxBV-og72-bKaH-5oym-MXtAaP

  ├─rhel-root
  │              xfs                22ed4ab7-7318-4532-af95-2858d3a90bb3      7.6G    55% /var/lib/containers/storage/overlay
  │
   /
  └─rhel-swap
                 swap   1           b79ba117-5f43-481e-ac57-44250b552145
[root@server ~]#
sdb

sr0  iso966 Jolie RHEL-9-4-0-BaseOS-x86_64
                        2024-04-12-03-32-56-00                       0   100% /run/media/mo/RHEL-9-4-0-BaseOS-x86_64

-----------------------------------------------

# we have to commands to work with partitions like creating ,deleting partitions 

1- most preferred with MPR scheme :
[ command : fdisk ]

2- most preferred with GPT scheme :

[ command : gdisk partition/path ]


[root@server ~]# gdisk /dev/sdb
GPT fdisk (gdisk) version 1.0.7

Partition table scan:
  MBR: protective
  BSD: not present
  APM: not present
  GPT: present

Found valid GPT with protective MBR; using GPT.

Command (? for help): ?
b       back up GPT data to a file
c       change a partition's name
d       delete a partition
i       show detailed information on a partition
l       list known partition types
n       add a new partition
o       create a new empty GUID partition table (GPT)
p       print the partition table
q       quit without saving changes
r       recovery and transformation options (experts only)
s       sort partitions
t       change a partition's type code
v       verify disk
w       write table to disk and exit
x       extra functionality (experts only)
?       print this menu
-
Command (? for help):
-------------------------------------------
# Making SWAP Partition

[ 1- frist of all create partition with type ( linux-swap ) ]

[root@host] parted /dev/vdb

(parted) mkpart

Partition name? []? Swap1 

File system type? [ext2]? linux-swap <<<<<<<<<<<<<<<<<<<<<<<< the most important section

Start? IOOIMB

End? 1257MB

(parted) print

(parted) quit

[root@host~] udevadm settle

[ 2- Formatting the Device ]

[root@host~] mkswap /dev/sdb2

[ 3- Activating a SWAP Space ]

[root@host swapon /dev/vdb2







........................................................

[command : fdisk -l ]

to list all the storage you have in our system 
 
                                                                                
┌──(root㉿kali)-[/home/mo]
└─# fdisk -l
Disk /dev/nvme0n1: 20 GiB, 21474836480 bytes, 41943040 sectors
Disk model: VMware Virtual NVMe Disk
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0xc2cdcabc

Device         Boot    Start      End  Sectors  Size Id Type
/dev/nvme0n1p1          2048 39942143 39940096   19G 83 Linux
/dev/nvme0n1p2      39944190 41940991  1996802  975M  5 Extended
/dev/nvme0n1p5      39944192 41940991  1996800  975M 82 Linux swap / Solaris



after restarting the machine:

└─# fdisk -l
Disk /dev/nvme0n1: 20 GiB, 21474836480 bytes, 41943040 sectors
Disk model: VMware Virtual NVMe Disk
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0xc2cdcabc

Device         Boot    Start      End  Sectors  Size Id Type
/dev/nvme0n1p1          2048 39942143 39940096   19G 83 Linu
/dev/nvme0n1p2      39944190 41940991  1996802  975M  5 Exte
/dev/nvme0n1p5      39944192 41940991  1996800  975M 82 Linu


Disk /dev/nvme0n2: 5 GiB, 5368709120 bytes, 10485760 sectors
Disk model: VMware Virtual NVMe Disk
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes

..now we can see that we have to diskes as i add disk in vmware
.........................................................................

mpr :partitioning scame called (dos) in operating system 

.......................................

NOTE : ther are id name for partitios to the normal partitions from the special ones 

the special partitions used from different diskes to make large vertiual storage like LVM

and to specialize the file system used in that partitions

........................................... 

┌──(root㉿kali)-[/home/mo]
└─# lsblk
NAME        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
sr0          11:0    1  3.5G  0 rom  
nvme0n1     259:0    0   20G  0 disk 
├─nvme0n1p1 259:1    0   19G  0 part /
├─nvme0n1p2 259:2    0    1K  0 part 
└─nvme0n1p5 259:3    0  975M  0 part [SWAP]
nvme0n2     259:4    0    5G  0 disk 
                                   
.......................................................................................................

we use 

[command fdisk diskpath (/dev/diskname) ]

to deal with disks

                                                     
┌──(root㉿kali)-[/home/mo]
└─# fdisk /dev/nvme0n2

Welcome to fdisk (util-linux 2.38.1).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Device does not contain a recognized partition table.
Created a new DOS disklabel with disk identifier 0x2560e9a6.

Command (m for help): 


..........................................................................................


                                                       
┌──(root㉿kali)-[/home/mo]
└─# fdisk /dev/nvme0n2

Welcome to fdisk (util-linux 2.38.1).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Device does not contain a recognized partition table.
Created a new DOS disklabel with disk identifier 0xee9e6515.

Command (m for help): m

Help:

  DOS (MBR)
   a   toggle a bootable flag
   b   edit nested BSD disklabel
   c   toggle the dos compatibility flag

  Generic
   d   delete a partition
   F   list free unpartitioned space
   l   list known partition types
   n   add a new partition
   p   print the partition table
   t   change a partition type
   v   verify the partition table
   i   print information about a partition

  Misc
   m   print this menu
   u   change display/entry units
   x   extra functionality (experts only)

  Script
   I   load disk layout from sfdisk script file
   O   dump disk layout to sfdisk script file

  Save & Exit
   w   write table to disk and exit
   q   quit without saving changes

  Create a new label
   g   create a new empty GPT partition table
   G   create a new empty SGI (IRIX) partition table
   o   create a new empty DOS partition table
   s   create a new empty Sun partition table


..........................................................................................................................


# now we will add nwe parteition

Command (m for help): n
Partition type
   p   primary (0 primary, 0 extended, 4 free)
   e   extended (container for logical partitions)
Select (default p): 
...........................................................................

# now we will chose the type of partition primary or extended

select (default p): p

.................................................................................................

# now we will selecte the partition number from 1 _ 4

Partition number (1-4, default 1): 1

.................................................................................................

# now we will selecte the sector from (2048-10485759) as it store the 2048 sectors for some thing we will konw later

the size of the sector is 512 byte 

104857 / 8 = 131072 kbit

131072 /1024 = 128 megabit

so it allocat 128 megabit to some thing so we have to allocat sectores after the frist 2048 sectors

..i clicked enter to start with sector 2048

...and it give massege to determine the last sectore 


Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-10485759, default 10485759):


# NOTE : we will find that we can determine the last sector by number or by kilo mega gega tera peta


# now i will tell him to make partition of 1giga

: +1G

Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-10485759, default 10485759): +1G

Created a new partition 1 of type 'Linux' and of size 1 GiB.

........................................................
# before writing the partition on te disk we have to enshure that what we done is right

by clicking on p

 p   print the partition table


Command (m for help): p

Disk /dev/nvme0n2: 5 GiB, 5368709120 bytes, 10485760 sectors
Disk model: VMware Virtual NVMe Disk
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x6ce01b52

Device         Boot Start     End Sectors Size Id Type
/dev/nvme0n2p1       2048 2099199 2097152   1G 83 Linux

now we have the partition we created 1G

 
...................................................................................................................................


# NOTE : evry thing we done is wiriten in the memory not applayrd yet

to applay changes click w

Command (m for help): w
The partition table has been altered.
Calling ioctl() to re-read partition table.
Syncing disks.

┌──(root㉿kali)-[/home/mo]
└─# lsblk /dev/nvme0n2
NAME        MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS
nvme0n2     259:4    0   5G  0 disk 
└─nvme0n2p1 259:6    0   1G  0 part 

- we can see that now the partition created in disk nvme0n2

.........................................................................................

# NOTE : whene creating new partition the kernel didnot know about him as 
               
- the kernel has readed the MPR partition taple in the booting  the machine so we have to tell him to reread the MPR partition taple to know about the new partitions

[ command :partprobe ]

- to scane all new diske's partitions


┌──(root㉿kali)-[/home/mo]
└─# partprobe /dev/nvme0n2 

- here we scane the disk nvme0n2 to know the new partitions on it


.........................................................................................................................................................................

# now we have to creat file system for the new partiton

[command : mkfs.(file system type) disk's partiton's path]

the defulte is ext2

we work with ext4,xfs,ntfs


──(root㉿kali)-[/home/mo]
└─# mkfs.ext4 /dev/nvme0n2p1
mke2fs 1.46.6-rc1 (12-Sep-2022)
Creating filesystem with 262144 4k blocks and 65536 inodes
Filesystem UUID: d68a350d-5c2b-4a9a-9e66-bd41cf361687
Superblock backups stored on blocks: 
	32768, 98304, 163840, 229376

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done

# NOTE : WE can determine the size of blocks the file sstem deal with 

# NOTE : Inode tables are called suber blocks

# NOTE : SUBER blocks has many copies in the partition we dont know were

---the copies of suber block make us can have the inode tsble againe if any thing bad happened to the source inodetable (suberblock)

........................................................................................................................................................................


┌──(root㉿kali)-[/home/mo]
└─# fdisk -l /dev/nvme0n2
Disk /dev/nvme0n2: 5 GiB, 5368709120 bytes, 10485760 sectors
Disk model: VMware Virtual NVMe Disk
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x6ce01b52

Device         Boot Start     End Sectors Size Id Type
/dev/nvme0n2p1       2048 2099199 2097152   2G 83 Linux

............................................................................................................................................................................
                                                      

today i created new partition nvme0n2p2 

──(root㉿kali)-[/home/mo]
└─# lsblk /dev/nvme0n2
NAME        MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS
nvme0n2     259:4    0   6G  0 disk 
├─nvme0n2p1 259:5    0   2G  0 part 
└─nvme0n2p2 259:6    0   1G  0 part 
...........................................................................................

to delet partiton use option d

──(root㉿kali)-[/home/mo]
└─# fdisk /dev/nvme0n2   

Welcome to fdisk (util-linux 2.38.1).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.


Command (m for help): d
Partition number (1,2, default 2): 1

Partition 1 has been deleted.

Command (m for help): w
The partition table has been altered.

----------
to make kernal reread partitions 
to edite partition table

──(root㉿kali)-[/home/mo]
└─# partprobe /dev/nvme0n2
.....
so we now have one partition                                                                  
┌──(root㉿kali)-[/home/mo]
└─# lsblk /dev/nvme0n2
NAME        MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS
nvme0n2     259:4    0   6G  0 disk 
└─nvme0n2p2 259:6    0   1G  0 part 

and we delet the othe partition
┌──(root㉿kali)-[/home/mo]
└─# lsblk /dev/nvme0n2
NAME    MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS
nvme0n2 259:4    0   6G  0 disk 
......................................................................................................................................................................

# NOTE :after deleting partitions from the disk the MPR(dos) is stell exist and its table

──(root㉿kali)-[/home/mo]
└─# fdisk -l /dev/nvme0n2
Disk /dev/nvme0n2: 6 GiB, 6442450944 bytes, 12582912 sectors
Disk model: VMware Virtual NVMe Disk
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x7fd11f95
                                                                            
...............................................................................

# NOTE : we have some files to generat randome things 

1-/dev/random

2-/dev/urandom

- we can use this file to rewrite on the disk to corapte it and corrapte MPR with partition table


cat /dev/random >> /dev/nvme0n2

┌──(root㉿kali)-[/home/mo]
└─# cat /dev/random >> /dev/nvme0n2

cat: write error: No space left on device
                                   
NOTE:now the disk become raw disk have no RPM(DOS)

──(root㉿kali)-[/home/mo]
└─# fdisk -l /dev/nvme0n2
Disk /dev/nvme0n2: 6 GiB, 6442450944 bytes, 12582912 sectors
Disk model: VMware Virtual NVMe Disk
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
........-------
# NOTE:   when using fdisk on raw disk at frist time it make MPR(dos) utomaticly

──(root㉿kali)-[/home/mo]
└─# fdisk /dev/nvme0n2   

Welcome to fdisk (util-linux 2.38.1).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Device does not contain a recognized partition table.
Created a new DOS disklabel with disk identifier 0x30acd8c5.

Command (m for help): p
Disk /dev/nvme0n2: 6 GiB, 6442450944 bytes, 12582912 sectors
Disk model: VMware Virtual NVMe Disk
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos   ←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←
Disk identifier: 0x30acd8c5



.........
# we can remove MPR on another way

[ command : dd if=/dev/random of=/dev/nvme0n2  count=512 ]

disk dome :dd

┌──(root㉿kali)-[/home/mo]
└─# dd if=/dev/random of=/dev/nvme0n2 count=512
512+0 records in
512+0 records out
262144 bytes (262 kB, 256 KiB) copied, 0.0285515 s, 9.2 MB/s
                            
this method is used to control what we write on the disk

.......

# NOTE:

- MPR is 512 byte

  > 64B for partion table

  > 446B for Boot Loader

  > 2B for magical number

--so in this method we determined count to chose the space we want to corrapte 

--:count is the numper of blocks we want to write in 

so we can corrabte all of the mpr or some blocks of it.

file :/dev/zero contain zeroes only

..formate = zerofill : write zeroes on space

.....................................................................................................................................

ex : creat new partition 1G file system ntfs

┌──(root㉿kali)-[/home/mo]
└─# fdisk /dev/nvme0n2

Welcome to fdisk (util-linux 2.38.1).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Device does not contain a recognized partition table.
Created a new DOS disklabel with disk identifier 0x8cc8e456.

Command (m for help): n
Partition type
   p   primary (0 primary, 0 extended, 4 free)
   e   extended (container for logical partitions)
Select (default p): p
Partition number (1-4, default 1): 1
First sector (2048-12582911, default 2048): 2048
Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-12582911, default 12582911): +1G

Created a new partition 1 of type 'Linux' and of size 1 GiB.

Command (m for help): w
The partition table has been altered.
Calling ioctl() to re-read partition table.
Syncing disks.

                                                                                                                                                                                                                                             
┌──(root㉿kali)-[/home/mo]
└─# partprobe /dev/nvme0n2
                                                                                                                                                                                                                                             
┌──(root㉿kali)-[/home/mo]
└─# mkfs.ntfs /dev/nvme0n2p1
Cluster size has been automatically set to 4096 bytes.
Initializing device with zeroes: 100% - Done.
Creating NTFS volume structures.
mkntfs completed successfully. Have a nice day.






....................................................................................................................................................................................................................................


# NOTE :when creating file system on partition and it have suber blocks the proccess will stoped
- we can force it to make file system by option -f

mkfs.xfs -f /dev/nvme0n2p1 

                                            
...........................................................................................................................................................................

.------now we have to mount the partition to be accessable

[ command : mount devic(partition) path ]

mount /dev/nvme0n2p1 /media/


──(root㉿kali)-[/home/mo]
└─# mount /dev/nvme0n2p1 /media/
                                                                  
┌──(root㉿kali)-[/home/mo]
└─# df -h                                      
Filesystem      Size  Used Avail Use% Mounted on
udev            936M     0  936M   0% /dev
tmpfs           195M  1.4M  194M   1% /run
/dev/nvme0n1p1   19G   14G  4.0G  78% /
tmpfs           974M     0  974M   0% /dev/shm
tmpfs           5.0M     0  5.0M   0% /run/lock
tmpfs           195M  120K  195M   1% /run/user/1000
/dev/nvme0n2p1  1.0G  5.6M 1019M   1% /media ←←←←←←←←←←←←←←←←←←←

to unmount it :

command : umount /meadia
                                    
──(root㉿kali)-[/home/mo]
└─# umount /media/
                                                                  
┌──(root㉿kali)-[/home/mo]
└─# df -h
Filesystem      Size  Used Avail Use% Mounted on
udev            936M     0  936M   0% /dev
tmpfs           195M  1.4M  194M   1% /run
/dev/nvme0n1p1   19G   14G  4.0G  78% /
tmpfs           974M     0  974M   0% /dev/shm
tmpfs           5.0M     0  5.0M   0% /run/lock
tmpfs           195M  120K  195M   1% /run/user/1000
                                    
.................................................................................................................................................................................

# to come with partition info use command:

[ dumpe2fs partition path ]

──(root㉿kali)-[/home/mo]
└─# dumpe2fs /dev/nvme0n2p1
dumpe2fs 1.46.6-rc1 (12-Sep-2022)
Filesystem volume name:   <none>
Last mounted on:          <not available>
Filesystem UUID:          6ad7490b-1ad4-4729-8131-96a451ea3432
Filesystem magic number:  0xEF53
Filesystem revision #:    1 (dynamic)
Filesystem features:      has_journal ext_attr resize_inode dir_index filetype extent 64bit flex_bg sparse_super large_file huge_file dir_nlink extra_isize metadata_csum
.......


this command work with ext4 ext3,2

.....................................................................................................................................................

# now we will see how to chick disk but it must be unmounted

──(root㉿kali)-[/home/mo]
└─# e2fsck /dev/nvme0n2p1

e2fsck 1.46.6-rc1 (12-Sep-2022)

/dev/nvme0n2p1: clean, 11/65536 files, 12955/262144 blocks
                                                         

# NOTE : we have to make backup to the partition we will check befor checking with optoin --forc to check 

# note : we use --forc whene it come with corrapted blocks



-----
# to make backup :

[ dd if=/dev/nvme0n2p1 of=/nvme0n2p1-backup ]


──(root㉿kali)-[/home/mo]
└─# dd if=/dev/nvme0n2p1 of=/nvme0n2p1-backup  
^C532157+0 records in
532157+0 records out
272464384 bytes (272 MB, 260 MiB) copied, 2.2818 s, 119 MB/s

                                                                  
┌──(root㉿kali)-[/home/mo]
└─# cd /       
                                                                  
┌──(root㉿kali)-[/]
└─# ls       
0     initrd.img      lost+found        root  usr
bin   initrd.img.old  media             run   var
boot  lib             mnt               sbin  vmlinuz
dev   lib32           nvme0n2p1-backup ←←←←←←←←←←←←←←←←←←←←←←←←←←←

# to back with backup

[ dd if=/nvme0n2p1-backup of=/dev/nvme0n2p1 ]

